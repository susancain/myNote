HTTP协议
	Web访问原理
	HTTP协议特点
		支持客户/服务器模式:只要有内容(客户端)能够发起类似HTTP协议的规范的内容,那么就可以被服务器接收为HTTP请求
		简单快速[只需请求方法和路径]: 理论上来讲只要有请求方法和路径就可以找到对应的服务器处理数据: 请求行(包含请求方法,URI), 请求头(HOST)
		灵活[任意数据]
		无连接[每次连接只处理一个请求]: 任何一个请求都只能得到一个响应, 一旦结束连接断开.
		无状态[事务处理没有记忆能力]: 基于无连接,导致服务器没有办法识别同一个浏览器(浏览器发起多次请求, 服务器不认识)
	HTTP协议分为两个部分: 
		HTTP请求和HTTP响应
	HTTP请求分为四个部分: 
		请求行, 请求头, 空行, 请求数据(所有内容都是独占一行)
	常见的HTTP请求协议项
		Host: 主机地址, 规定到底要获取服务器哪个虚拟主机下的内容
		HOST: www.itcast.cn(一定得有)
		accept-encoding: 浏览器能够接收服务器上面格式的编码(不是字符集), gzip,gflate等
		Referer: 引用, 当前的浏览器发起的请求,是从上一个界面过来(上一个界面的URL)
		Connection: 保持连接, 浏览器与服务器的请求过程是一次性的: 浏览器发起一次请求只能获得一次响应, connection表示在一次请求过程中,不要立即断开(keep-alive)
		accept-language: 可以接收的语言, 中文zh-cn,英文等
		Cookie: cookie本身是一种服务器将数据存储在浏览器上的一种技术, 基于HTTP协议中的cookie技术: 将服务器原来存储在浏览器上的数据携带给服务器
		user-agent: 用户代理, 代表当前浏览器所在客户端的一些基本信息
		Accept: 接收的类型, text/html, image/png等
		content-length（post）: 内容长度, 只有POST提交数据的时候才会有
		if-modified-since（get）: 当浏览器缓存了服务器已经被请求过的文件, 浏览器又再次发起请求: 发送的内容是上次缓存文件的时间
		content-type（post））: 内容类型, post数据提交的时候需要对数据进行转码才能提交: application/x-urlencoded

		空行: 告诉服务器请求头结束了,后面的内容是请求数据

		请求数据: 数据的隐藏提交(数据表): 表单名字=值&表单名字=值

	telnet模拟HTTP请求

		HTTP响应也分为四个部分: 状态行(响应行), 响应头,空行, 响应体
		响应头: 与请求完全一致,只是协议内容不一样(一个协议独占一行)
		常见的响应头有
		Server: 服务器信息
		Date: 当前的响应时间(系统时间)
		last-modified: 最后修改时间,对应请求中的if-modified-since
		content-length: 响应数据的长度
		content-type: 数据类型
		Location: 重定向: 告诉浏览器立即重新发起请求
		Refresh: 重定向: 告诉浏览器在指定时间之后重新发起请求
		content-encodeing: 对应请求头中的access-encodeing,编码格式: gzip,deflate等
		cache-control: 缓存控制,告诉浏览器是否需要混村数据: no-cached不要缓存

		空行: 告诉浏览器响应头结束:以下内容是响应体

		响应体: HTML代码(最终的数据)
	状态码
		状态码: 协议规定服务器在做完处理之后, 需要通过一系列编码告诉浏览器处理的结果是什么样的
		状态码分为5类:
			1XX: 表示服务器正在处理,还没有处理完(接收,处理)
			2XX: 服务器已经正常处理完毕
			3XX: 重定向, 当前处理需要浏览器再次配合
			4XX: 浏览器错误: 服务器对浏览器的请求不予配合
			5XX: 服务器错误: 服务器不能正常处理请求
		常见的状态码
			200: OK, 请求成功, 服务器已经正确处理完毕
			302: Found, 当前请求的URL(文件)已经转移
			303: See Other, 当前请求的文件被转移
			304: Not Modified, 服务器没有修改, 浏览器访问本地缓存(if-modified-since)
			400: Bad Request,错误的请求
			403: Forbidden,没有访问权限
			404: Not Found, 请求的脚本不存在
			502: Bad Gateway, 网关错误, 服务器需要从其他服务器获取结果: 没有获取到

PHP修改响应头
	跳转功能
		location: 重定向, 直接重定向(不需要等待缓冲,浏览器立马发起新的请求)
		header(‘location:重定向目标’);
	界面刷新
		location不能输出数据, 但是refresh可以.
		header(‘refresh:刷新等待时间;url=跳转的目标’);
	输出图片
		告诉浏览器指定图片的格式.
		content-type: 格式(MIME类型格式)
		header(‘Content-type: image/gif, image/png, image/jpg, image/jpeg’);
	下载内容
		下载的本质: 阻止浏览器解析, 当做附件处理
		Content-type: application/octet-stream; 流处理
		Content-dispositon:attachment;filename=建议名字
	协议修改注意事项
		修改协议前: 不能有任何输出: 系统一旦碰到输出, 就会认为协议已经组织结束: 所有后面的内容全部都是数据.
		证明: 将程序缓存关闭: PHP就会代码解析一句就给apache返回一句: apache一旦检测到内容不是协议: 就会将后续的所有内容都当做数据.
		output_buffering
		将程序缓存变成0: 不缓存
	PHP模拟HTTP请求
		模拟GET请求
		1.使用PHP与服务器建立连接
		fsockopen: 与服务器建立连接, 成功返回一个连接资源,失败返回false
		2.发送HTTP请求协议: 请求行,请求头,空行,请求数据(GET没有)
		fputs/fwrite: 向资源写入数据
		3.从资源中解析响应结果(读取结果)
		fgetc/fgets/fread: 读取资源中内容
		4.释放资源
		fclose
	模拟POST请求
		POST比GET请求多了几个协议: 数据, 数据长度, 数据编码
		1.建立连接
		2.准备HTTP请求
		3.发送HTTP请求
		4.解析响应
		5.关闭资源

	要实现攻击: 不断的发送请求
	让脚本可以执行不受时间限制: 在脚本执行之前加一个执行周期控制
	set_time_limit(0): 0代表永远执行
算法
快速排序算法
快速排序: 效率比较高, 使用空间换时间(递归)
原理: 从一个数组中,随机取出一个元素: 以该元素为基准,将数组中剩余的其他元素挨个的与当前元素进行比较: 比元素小的存放到一个数组, 比元素大的也存放到一个数组. 当所有的元素都比较完之后: 一定会确定中间元素(取出的元素)的位置.
两边的数组依然需要排序: 利用上述解决问题的方式解决子问题(递归点),直到数组元素个数为1, 再返回(递归出口), 返回的结果与上述的结果进行合并.

代码实现
1.定义函数

2.取出第一个中间元素

3.从第二个元素开始进行遍历比较

4.合并数组返回


5.找到递归点: 左右两边的数组没有排好序(需要排序): 刚好函数所要做的事情就是排序数组: 对数组进行排序(递归调用)

6.递归出口: 什么时候函数不再自己调用自己: 数组元素的个数不能小于1

二分查找算法
二分法又称之为折半算法: 是指针对一个已经排好序的数组中去找到对应的元素的位置
原理: 将数组折半,找到中间元素: 将中间元素与要找的元素进行比较: 如果一样,返回位置(找到了);如果比元素小, 将后半部分再查找; 如果比元素大, 将前半部分进行查找;

代码实现
1.定义待排序数组

2.求出数组的长度

3.求出当前要求的内容所在数组的哪个区间

4.找出当前的第一个中间位置下标

5.开始查找: 目标值是3

6.重新计算middle的位置

7.考虑到边界值的问题: 发展的最终有可能是左边 == 右边: 修改循环条件